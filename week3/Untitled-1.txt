Binary Search
	介紹
		Q:現在給你一個已經照大小順序排好的數列，怎樣快速的找到x這個數字的位置(或是告知x不存在)?
		A:
			1.看一下數列正中間的值，如果剛好等於x代表你找到了
			2.不是的話，想一下x會在左半邊還是右半邊，然後把沒有x的那半邊丟掉
			3.如果數列還有東西，回到步驟1，不然代表找不到
		時間複雜度: O(ClgN) C是檢查的時間複雜度，N是數列的大小
		常用的地方:
			1.找東西
			2.求符合某條件的最小(最大)值
			3.奇怪的互動題
	虛擬碼
		int l=0,r=n-1
		while(l<=r)
			int mid=(l+r)/2
			if(l<mid)
				r=mid-1
			else
				l=mid+1
		ans=l
	相關STL:
		1.upper_bound
			template <class ForwardIterator, class T, class Compare>
			ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last,
				const T& val[, Compare comp]);
		2.lower_bound
			template <class ForwardIterator, class T, class Compare>
  			ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last,
				const T& val[, Compare comp]);
		3.binary_search
			不常用(僅回傳bool)
		4.equal_range
			相當於回傳make_pair(lower_bound...,upper_bound...);
	例題:
		1.第K大連續和(TIOJ 1208)
			一個總長度為項的數列S，其連續和共有n(n+1)/2個。請問，這n(n+1)/2個連續和之中，第k大的是多少？
		2.洞穴Cave(TIOJ 1839)
			你迷路了。你發現一個入口。入口被連續N個門阻隔。有N個開關分別連接到這N個不同的門。
			門依序由0~N-1編號，最接近你的那扇門編號為0。開關編號也是0~N-1但你並不知道哪個開關連到哪扇門。
			開關都位於洞穴的入口處。每個開關可以被設定成上或下。每個開關只有一個方向是正確的。若一個開關被設定在正確的方向，則其連接到的門便會打開，反之則否。每一個開關的正確方向可能不相同，現在你並不知道開關的正確方向。
			你可以將開關設定成任何的組合，並且走入這個洞穴觀察第一個未開的門。這些門都是不透明的，當你發現第一個未開的門時，你無法看到任何後方的門。
			你可以嘗試最多70,000種組合。你的任務是把所有的門都打開。
Divide & Conquer 
	介紹
		大陸稱之為分治，有些奇怪的人稱之為Fun Jizz，是一種常見的算法設計方法。
		步驟
			1.切開 把問題切碎
			2.處理 把碎片解決
			3.合併 把碎片合併
		時間複雜度
			時間複雜度通常都是一個遞迴函式，推出一般項的方法有亂猜後用數學歸納法證明，劃出遞迴樹以及使用主定理(Master theorem)。有興趣可以自己去Google。
		常用的地方:
			許多的算法都有運用到分治的想法，例如前面所說的二分搜、merge sort、快速矩陣乘法、最近點對等等...
			一般出現的時候，如果不是已經看過的類型，通常很難當場想出來。
	例題
		1.逆序數對(TIOJ 1080)
			輸入一個數列，輸出數列中有多少數對是逆序的。
		2.河內之塔-蘿莉塔(TIOJ 1355)
			有三根柱子，第一根上有圈圈，每個大小都不一樣，且大的在下面，然後請輸出如何把所有的圈圈移到第三根柱子上，過程中不能讓小的圈圈在大的圈圈下面。
		3.平面最近點對(TIOJ 1500)
			給你平面上N個點，問最近的兩個點有多近。
		4.樹分治(POJ 1741)
			給你一棵樹，問樹上距離<=K的點對數量。
		5.點連接遊戲(TIOJ 1631)
			在正方形xy平面上給你N個紅點跟綠點(左上右上紅點，左下右下綠點)，保證三點不共線，請用不交叉的數個線段分別把紅點跟綠點連起來。
Dynamic Programming
	名詞解釋
		最佳化問題(Optimization Problem)，是從諸多可行解中找出的最佳解(Optimal Solution)的問題。 
  		動態規劃(Dynamic Programming)，簡稱DP，是解決每種最佳化問題的典型策略，許多的最佳化問題都要由一連串的決策導出，而當我們面對這些決策時，會不斷的出現擁有相似型態的子問題。
	介紹
		What
			DP使用將原問題分解成子問題的方式推導出源問題的解答。我們常常把原問題分解成數個較容易解決的子問題，如果子問題還是過難的話，就繼續分解成更多的子問題。而當不同子問題的最佳解可能來自相同的子子問題的時候，次技巧精妙之處就是把處理過的解答存起來，以免重複計算，因此適合以DP解決的問題通常都有子問題重疊(Overlapping Subproblems)的性質，也就是不同子問題最佳解可能會包含相同的子子問題。
		When
			但是也不是所有最佳化問題都能使用DP來解決，適合使用DP的最佳化問題也需要滿足幾個特性才能確保DP的正確性。
				1.最佳子結構
					問題的最佳解中含有子問題 的最佳解，也就是說問題的最佳 解可以由子問題的最佳解推得。
				2.無後效性
					若子問題決定的母問題最佳 解會影響到子問題的最佳解，則 有後效性。
		How
		 	使用DP解決問題時，我們通常會先辨認出問題的結構特徵，然後遞迴更新各個最佳解，如果有需要則會將計算過的子問題存起來，方便重複取用而不必重複計算，從而提高效率。 
  			一般實作時主要分為兩種風格
			  	1.Bottom-Up
				  	從最小的子問題開始計算答案，逐漸算出更大子問題的答案，直到算出目標解為止。 
  					優點:可以直接使用迴圈跑過整個表格計算出答案，且適當的設計迭代順序的話還可以壓縮記憶體使用量。 
  					缺點:遇到狀態較多的題目表格會太大，可能會計算無用的子問題。
				2.Top-Down
				 	從原問題開始遞迴計算子問題，將算過的子問題最佳解存起來，並逐步地算出答案 
  					優點:不會計算到多於的子問題，且子問題數目很多時仍可使用。 
  					缺點:表格大小會和子問題總數一樣大，呼叫函式遞迴也需要負擔額外的成本。
	例題
		1.工廠生產問題
			一間工廠有兩條生產線，生產線上各有N個工作站，兩條生產線對應的工作站工作相同但是效率不同，你可以把一條生產線中的半成品轉到另外一條生產線上(需要成本)，做每件事情的成本可能都不相同，問生產一件產品所需的最小成本是多少?
		2.最大正方形
			給你一個只含0跟1且大小為N*N的正方形，問最大只由1組成的方形可以多大?
		3.A Game (TIOJ 1029)
			有一串由N個正整數所組成的數列，兩個玩者輪流拿走一個最左邊或最右邊的數，直到最後所有的數都取完之後，兩個玩者分別把自己所取到數加總，分數較高的人獲勝。問兩個玩家分別所能得到的最高分數是多少?
		4.切木棒
		 	你有一根長度N 的木棒，對於長度1,2...N的木棒，某商人願意畫a1,a2...N 的價格跟你購買，如果切木棒不花錢問你最多能賺多少錢?
		5.01背包問題
			你擁有一個載重V 的背包，和N個物品，每個物品都有各自的重量和價值，問你在不超重的前提下，最多可以裝多少價值的物品?
		6.石油 (TIOJ 1816)
			給你一個n*m的矩陣，請從中選出三個互不覆蓋的且大小為k*k的正方形，並最大化總和
		7.兔子跳鈴鐺(TIOJ 1019)
			給你N個鈴鐺的水平位置，你每次可以從x跳到x+1或x+2的鈴鐺上，問從第1個跳到第n個鈴鐺所需的最小水平移動距離
		8.打地鼠(TIOJ 1014)
			有編號1,2,⋯,n的地鼠動。玩家站在最左邊，與第一個地鼠洞相距1公尺，準備開始這個遊戲。編號為 i 的地鼠洞每Ti秒地鼠會出現一次。被打的地鼠不再出現，所有地鼠打完就結束遊戲，問結束遊戲所需的最少秒數。
		9.Relay Race(codeforces 214E)
			現在你有一個n*n的矩陣，你要選兩條(1,1)->(n,n)的捷徑，讓兩條路徑聯集上的數字總和最大
		10.一切的開始(Step5 0004)
			有N隻殭屍A1,A2,...AN排成一排，殭屍分兩種，你想要讓所有殭屍都變第一種，你可以改變一隻的屬性，或是改變A1~Ax的屬性，問你最少要改幾次。
		11.數Misaka妹妹(Step5 0093)
			你想要數數看排了多少御坂妹妹，但你卻發現自己每連續數到n個御坂妹妹眼花，如果眼前總共有m個人在排隊，那麼有幾種排列方式是不會算錯的呢？
Greedy
	介紹
		What
			Greedy使用一個很當純的想法尋找答案，就是每次只選擇當前看似最佳的選擇。換言之我們每次都選擇當前最佳解，並期望能達到全局最佳解。因此Greedy不一定能得到問題的最佳解，但是當他被證明可行時(否則他只能獲得近似解)，Greedy通常也會是這個問題的最佳策略，因為他放棄搜尋所有解答空間，效率也因此提高很多。
		When
			原則上要符合兩個特性才能使用Greedy
				1.最佳子結構
					問題的最佳解中含有子問題 的最佳解，也就是說問題的最佳 解可以由子問題的最佳解推得。
				2.貪婪選擇屬性
					每次決策時我們可以選擇當前看似最佳的選擇，並在繼續Greedy下去。也就是說每次決策的時候只考慮目前為止做過的選擇，不考慮未來可能要做的選擇或是子問題的解答。
		How
			觀察
				看到題目後先想想他有沒有一些特性
			假設
				接者假設如果再做一個決策的時候，用怎麼樣的方法很有可能會朝向是最佳解的方向
			證明
				證明每次的決策"這樣做不會更差"(結果會在最佳解上)，然後增加coding信心
	例題
		1.賣場監視器
			給你每個人進出賣場的時間，問賣場什麼時候人最多?
		2.找零錢
			大多數國家的貨幣面額都設計過，使得用貪婪策略都剛好會是硬幣數量最少的最佳湊法?
		3.惱人的零錢(NPSC2005 pB)
			咚咚想要買一個價格為C的物品，告訴你咚咚和老闆個別擁有的1,5,10,20,50硬幣的數量，請輸出找完錢後咚咚最少能剩下多少硬幣?
		4.湊零錢(TOI2015 二模)
			有一些面額為1,5,10,50,100,500,1000的錢幣，問你用這些硬幣最小湊不出來的錢是多少?
		5.誰先早餐(NPSC2005 pA)
			給你n個想要吃早餐的人和一個廚師。大家可以一起吃，但是廚師一次只能做一到菜。給定每人要吃多久，及他吃的那道菜要做多久，問至少需要多少時間所有人才能都吃完?
		6.背包問題(Step5 0021)
			有兩個背包的容量分別為N,M現在要將N+M個物品放進背包，每件物品都有它的重量，求字典序最小的放法使兩個背包分別的重量平均數加起來最小。
		7.蘿莉切割問題(Step5 0031)
			你要將一塊長L的木板切成N段，每段長度是Ai(A1+A2...+An=L)，而將一塊長X的木板切開需要X的花費，問花費最小的方法?
		8.看動畫(HOJ 28)
			你有一台有m個USB孔的電腦，還有編號1~N的隨身碟，現在你想要照一定的順序來看隨身碟裡的動畫，問最少的隨身碟插拔次數?
		9.錢包的路(TIOJ 1636)
			地上有一排的錢包(每個相距1步的距離)，你每走到一個錢包上面，就可以拿走裡面的錢。當你走一步路，地上錢包裡的錢就會恢復。問你走玩N步後，最多可以獲得多少錢?
		10.骨牌遊戲,H遊戲秘笈(TIOJ 1432,1465)
			給定一個長為N的數列，求使分成K段之後每段總和的最大值最小的分法。